---
title: "Introduction to the 'CCAMLRGIS' R package"
author: "Lucy Robinson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the 'CCAMLRGIS' R package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

This vignette describes the R package "CCAMLRGIS". The CCAMLRGIS package was developed to create new georeferenced data in the CCAMLR Convention Area for visualisation (i.e. mapping) and/or analyses and for reading existing georeferenced data that is displayed on the CCAMLR online GIS (https://gis.ccamlr.org/) directly from the webpoint end service into R. The package has a number of create functions for creating polygons, polygon grids, lines or points and a series of load functions for reading existing georeferenced data that has been agreed by the Commission and is documented in CCAMLR's Conservation Measures or in Scientific Committe reports. 

The main purpose of this package is to:
(1) facilitate the use of CCAMLR's spatial data by members and the wider scientific R user community and;
(2) To enure the spatial data presented at CCAMLR's Working Group meetings and the Scientific committe conforms with the projection and processing choices that have been agreed by CCAMLR (or something along these lines)

To understand what is covered in this vignette, you must understand the basics of the R language. There are a number of on-line and other resources that can help you to get acquainted with it. The CCAMLRGIS package does not operate in isolation. There are a number of R package that the CCAMLRGIS package requires and other R packages that it compliments. Package requirements can be viewed under Imports in the DESCRIPTION file and in individual functions. 

One complementary package is "graticule". Graticules are the lines of constant longitude and latitude shown on a projected map, and defining and drawing these lines is not easy to automate. The graticule package provides the tools to create and draw these lines by explicit specification by the user. The relevant functions from the graticule package will be included in examples provided below.

To install the CCAMLRGIS from github you will firstly need to install devtools (i.e. install.packages("devtools")) and then use the following command:

```{r, eval = FALSE}
devtools::install_github("lucymerobinson/CCAMLRGIS",build_vignettes=TRUE)

```

## Create Polygons

Polygon data often needs to be created when new scientific research areas and/or management areas are being proposed. The create_Polys function has been developed to create polygons that conform to CCAMLR's standards/specifications that can be used in analyses or to generate maps in R. 

See ?create_Polys for function input specifications


### Example of creating a proposed Research block

```{r}
library(CCAMLRGIS)
# Create research block polygon 

# specify the name of the Research block
Name <-"5841_6"
# specify the Latitude coordinates in decimal degrees
Lats <- c(-64.0, -65.5, -65.5,-64.0)

# specify the Longitude coordinates in decimal degrees
Lons <- c(130, 130, 134, 134)

# bind information together into a dataframe for input into the create_Polys function see ?create_Polys 
Coords <- data.frame(Name=rep(Name,length(Lons)),Lats=Lats,Lons=Lons)

# create polygon of proposed Research area to use in further Analyses
New_RB <- create_Polys(Coords)
```

The function automatically calculates a plantimetric area estimate based on the geometry of "New_RB". For details on how this area is caculated see ?create_Polys and to access the estimate:

```{r}

New_RB$AreaKm2

```

The SpatialPolygonDataFrame "New_RB"" can be used in further analyses in R (as per the above example) because the default parameter option for OutputFormat="ROBJECT".
You can also output as an ESRI Shapefile for use in other programs by specifying OutputFormat="SHAPEFILE" and a name for example: OutputName="RB_5841_6"


## Load CCAMLR's reference data into R

CCAMLR's reference data include management areas, defined in Conservation Measures and/or Scientific Committee reports (e.g. ASD's, SSRU's, etc). The text and/or geographical coordinates that are used to create polygons that define the reference area boundaries are stores in the CCAMLR's central database in SQL Server Spatial. These data, that are displayed as layers on the online GIS, are also stored in GeoJSON format, in an online geoserver repository, that allows them to be loaded directly into R. 


### Example of loading ASD's into R 

```{r,eval=FALSE}
# load ASDs from the online GIS - you will need to be online for this to work see 
?load_ASDs 
ASDs <- load_ASDs("GEOJSON")
```

```{r, include = FALSE}
## fakey it
ASDs <- load_ASDs("RDATA")
```
```{r}
# index ASD in the area of interest - e.g. 58.4.1
ASD_5841 <- ASDs[ASDs$GAR_Short_Label%in%"5841",]

```

### Prepare a simple map with the proposed Research Block 

### Load graticule library that will be added to map plot below

See ?graticule for function input specifications

```{r}
# add graticules and store locations of labels
library(graticule)
#> Loading required package: sp

# create graticules for plotting below
meridians <- seq(80,150, by = 10)
parallels <- seq(-90, -55, by = 5)


mlim <- c(min(meridians), max(meridians))
plim <- c(min(parallels), max(parallels))
grat <- graticule(lons = meridians, lats = parallels, xlim = mlim, ylim = plim, proj = raster::projection(New_RB))
labs <- graticule_labels(meridians, parallels, xline = 140, yline = -57.5, proj = raster::projection(New_RB))
```

### Plot ASD and Research Blocks with graticules

```{r}
par(mar=c(1,1,1,1))
raster::plot(ASD_5841)
text(sp::coordinates(ASD_5841), labels=as.character(ASD_5841$GAR_Short_Label),cex=1,col="black")
raster::plot(New_RB,add=TRUE,border="red")
text(sp::coordinates(New_RB), labels=as.character(New_RB$name),cex=1,col="black")
# add graticules to plot
raster::plot(grat, add = TRUE, lty = 3,lwd=1.5)
text(labs, lab = parse(text= labs$lab), col= "black", cex = 0.7)

```

## Create Polygon Grid 

Polygon grids are useful for displaying catch quantities at a resolution that can be specified by the user. The create_PolysGrids function has been developed to create polygon grids to display variation in quantity of target species catch.

See ?create_PolysGrids for function input specifications


### Example of creating a Polygon Grid of Krill catch

```{r}
# Create example catch data with Longitude and Latitude

# specify the Latitude coordinates in decimal degrees
Lats <- rnorm(1000,mean=-62,sd=0.25)
# specify the Longitude coordinates in decimal degrees
Lons <-sample(seq(-60,-50,0.01),1000,replace=TRUE)

Catch <- sample(100:1000,length(Lons),replace = TRUE)
# bind information together into a dataframe for input into the create_Polys function see ?create_Polys 
Catch_data <- data.frame(Lats=Lats,Lons=Lons,Catch=Catch)

# create polygon of proposed Research area to use in further Analyses
New_Grid <- create_PolyGrids(Catch_data,dlon=2,dlat=1)
```

The SpatialPolygonDataFrame "New_Grid"" can be used in further analyses in R (as per the above example) because the default parameter option for OutputFormat="ROBJECT".
You can also output as an ESRI Shapefile for use in other programs by specifying OutputFormat="SHAPEFILE" and a file name. For example OutputName="KrillCatch_Grid"



The function automatically summarises the numerical data included in each polygon cell. For details on summary output see ?create_PolyGrids. The summary information appears as follows. Note this only includes data on the first six polygons

```{r}

head(New_Grid@data)

```


The function automatically summarises the numerical data included in each polygon cell. For details on summary output see ?create_PolyGrids. The summary information appears as follows. Note this only includes data on the first six polygons

```{r}

head(New_Grid@data)

```


### Prepare a simple map of the Polygon Grid 

### install and load classInt and RColorBrewer package.

The ClassInt package will find appropriate intervals for plotting

The RColorBrewer package provides a variety of color ramps for plotting


```{r}
# install.packages(c("classInt","RColorBrewer"))
library(classInt)
library(RColorBrewer)

```

### Plot Polygon Grid of Catch with ASD 48.1 and graticules

```{r}
# specify lables for graticules
meridians <- seq(-70,-50, by = 10)
parallels <- seq(-90, -55, by = 5)

mlim <- c(min(meridians), max(meridians))
plim <- c(min(parallels), max(parallels))
grat <- graticule(lons = meridians, lats = parallels, xlim = mlim, ylim = plim, proj = raster::projection(New_RB))

labs <- graticule_labels(meridians, parallels, xline = -55, yline = -62, proj = raster::projection(New_RB))

#specify colour ramp
cols <- brewer.pal(n = 5, name = "RdYlGn")
breaks<-classIntervals(New_Grid$Sum,5)
# add a very small value to the top breakpoint, and subtract from the bottom for symmetry 
br <- breaks$brks
offs <- 0.0000001 
br[1] <- br[1] - offs 
br[length(br)] <- br[length(br)] + offs 

plot(ASDs[ASDs$GAR_Short_Label%in%"481",])
plot(New_Grid, col=rev(cols)[cut(New_Grid$Sum, br)],add=TRUE)
# add graticules to plot
raster::plot(grat, add = TRUE, lty = 3,lwd=1.5)
text(labs, lab = parse(text= labs$lab), col= "black", cex = 0.7)

```


## Create Lines

It can be useful to useful to create spatial line data to represent/analyse a variety of data that are collected and examined in the CCAMLR Convention Area such as longline sets, vessel tracks or animal tracks. The create_Lines function has been developed to create spatial lines that conform to CCAMLR's standards/specifications that can be used in analyses or to generate maps in R. 

see ?create_Lines for function specifications

### Example of creating lines that represent longline sets 

```{r}

## specify the name of the lines

Name <- c(rep("Set_1",2),rep("Set_2",2))

## specify the Longitude coordinates in decimal degrees

Lon <- c(-99,-98.5,-101,-101.3)

## specify the Latitude coordinates in decimal degrees
 
Lat<- c(-69.1,-69.1,-70.2,-70)

## bind information together into a dataframe 

Coords<- data.frame(Name=Name,Lat=Lat,Lon=Lon)

## create polygon of proposed Research area

New_Lines <- create_Lines(Coords)
```

The SpatialLineDataFrame "New_Lines" can be used in further analyses in R (as per the above example) because the default parameter option for OutputFormat="ROBJECT".
You can also output as an ESRI Shapefile for use in other programs by specifying OutputFormat="SHAPEFILE" and and output name for example: OutputName="Longlines_Subarea883"


The create_Lines function also calculates the length of the line that you create in kilometers and nautical miles. This can be accessed using 

```{r}
# to access line length in km
New_Lines$LengthKm

# to access line length in NM
New_Lines$LengthNm

```


### Plot Lines with graticules


```{r}

# create graticules for plotting below
meridians <- seq(-105,-95, by = 1)
parallels <- seq(-90, -55, by = 1)


mlim <- c(min(meridians), max(meridians))
plim <- c(min(parallels), max(parallels))
grat <- graticule(lons = meridians, lats = parallels, xlim = mlim, ylim = plim, proj = raster::projection(New_Lines))
labs <- graticule_labels(meridians, parallels, xline = -100.2, yline = -69.5, proj = raster::projection(New_Lines))


par(mar=c(1,1,1,1))
raster::plot(New_Lines,col="red")
# add graticules to plot
raster::plot(grat, add = TRUE, lty = 3,lwd=1.5)
text(labs, lab = parse(text= labs$lab), col= "black", cex = 0.7)

```


## Create Points

It can be useful to useful to create spatial point data to represent monitoring sites, fishing locations and VME locations. The create_Points function has been developed to create spatial points that conform to CCAMLR's standards/specifications that can be used in analyses or to generate maps in R. 

see ?create_Lines for function specifications

### Example of creating lines that represent longline sets 


```{r}

# specify the name of the points

Name <- c("Point_1","Point_2","Point_3")

# specify the Latitude coordinates in decimal degrees

Lat<- c(-70.2,-70.1,-69.9)

# specify the Longitude coordinates in decimal degrees

Lon <- c(-160,-161,-159)

# bind information together into a dataframe 

Coords<- data.frame(Name=Name,Lat=Lat,Lon=Lon)

# create points 

New_Points <- create_Points(Coords)

```

### Plot points in Subarea 88.2 with graticules


```{r}

# create graticules for plotting below
meridians <- seq(-180,-100, by = 10)
parallels <- seq(-90, -55, by = 5)


mlim <- c(min(meridians), max(meridians))
plim <- c(min(parallels), max(parallels))
grat <- graticule(lons = meridians, lats = parallels, xlim = mlim, ylim = plim, proj = raster::projection(New_Points))
labs <- graticule_labels(meridians, parallels, xline = -140, yline = -67.5, proj = raster::projection(New_Points))


# set plotting margins to zero on all sides
par(mar=c(0,0,0,0))

# select Subarea 88.2 from ASDs polygon data

raster::plot(ASDs[ASDs$GAR_Short_Label%in%"882",])

# add points to the plot

raster::plot(New_Points,col="red",add=TRUE,pch=20)

# add graticules to plot

raster::plot(grat, add = TRUE, lty = 3,lwd=1.5)
text(labs, lab = parse(text= labs$lab), col= "black", cex = 0.7)

```

## Calculate seabed area 

Calculating seabed area within particular depth ranges can be useful in a CCAMLR context for designing depth stratified surveys for estimating local toothfish biomass. The seabed_area function has been developed to provide seabed_area estimates within what is commonly classified as a fishable seabed depth range of 600-1800m. 

To see input requirements see ?seabed_area

### Bathymetry data

Bathmetry data is necessary to calculate seabed area. A processed version of the General Bathymetric Chart of the Oceans (GEBCO) 2014 data that has been restricted to a Research Block in Subarea 48.2 (482_S) within a fishable depth range (600-1800m) has been included for the examples below, but the full dataset (across the Convention Area) can be requested from the CCAMLR Secretariat.

```{r}

bathymetry_data_fn <- system.file("extdata","GEBCO_2014_600_1800m_482_S.grd",package = "CCAMLRGIS")

bathymetry_data <- raster::raster(bathymetry_data_fn)

```


### Example of estimating fishable seabed area in a Research Block

Load Research Block data and restrict the attribute data stored in the SpatialPolygonDataFrame to "GAR_Short_Label" 

```{r,eval=FALSE}
# load Research Blocks from the online GIS - you will need to be online for this to work see 
RBs <- load_RBs("GEOJSON")
```

```{r,include=FALSE}
RBs <- load_RBs("RDATA")
```
```{r}
# select data column names in GAR_Short_Label
RBs <- RBs[,names(RBs)%in%"GAR_Short_Label"]

```

Select a Research Block of interest. For example, the Research Block in Subarea 48.2 - 482_S

```{r}
RB_482_S <- RBs[RBs$GAR_Short_Label%in%"482_S",]
```

Estimate fishable seabed area in Research Block 482_S

```{r}
seabed_area_482_S <- seabed_area(bathymetry = bathymetry_data,ROI = RB_482_S,fishable_area = TRUE)
```

The output from the funtion is two column dataframe. The first column, under the column name "Region" contains the label or name of the polygon that was included in the SpatialPolygonDataFrame input into the seabed_area function. The seconde column, under the column name "Total area", is the estimated planimetric seabed area (km2) in the fishable depth range. 

```{r}
seabed_area_482_S

```


### Example of estimating seabed area in multiple depth classes in a Research Block

In this example we estimate the seabed area in four depth classes in Research Block 482_S

The depth classes (within the fishable seabed area depth range) are divided into 300m intervals as follows: 

```{r}
depth_classes <- c("600-900","900-1200","1200-1500","1500-1800")
```

And the seabed area in each depth class in Research Block 482_S is calculated:

```{r}
seabed_area_482_S_depth_classes <- seabed_area(bathymetry = bathymetry_data,ROI=RB_482_S,fishable_area = FALSE,depth_classes = depth_classes)
```

The output from the funtion is a dataframe that includes the region name, total area and then area in area of each of the specified depth class intervals. The first column, under the column name "Region" contains the label or name of the polygon that was included in the SpatialPolygonDataFrame input into the seabed_area function. The seconde column, under the column name "Total area", is the estimated planimetric seabed area (km2) in the fishable depth range and the subsequent four columns include the seabed area in each of the specified four depth classes. 

```{r,eval=FALSE}

seabed_area_482_S_depth_classes

```
